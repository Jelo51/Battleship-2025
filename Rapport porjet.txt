# Rapport Technique Détaillé - Battleship-2025

## Vue d'ensemble de l'architecture

Le projet Battleship-2025 suit une **architecture modulaire en couches** qui sépare clairement les responsabilités :

```
┌─────────────┐
│   main.c    │  ← Point d'entrée et orchestration
├─────────────┤
│   game.c    │  ← Logique métier et interactions
├─────────────┤
│   board.c   │  ← Gestion des données du plateau
└─────────────┘
```

Cette organisation respecte le principe de **séparation des préoccupations** et facilite la maintenance, les tests et le travail en équipe.

---

## Analyse détaillée de chaque fichier

### 1. **main.c** - Le chef d'orchestre (30 lignes)

**Rôle unique** : Coordonner l'exécution du programme sans logique métier.

```c
int main(void) {
    Board board;
    init_board(&board);        // Initialisation
    choose_placement(&board);  // Configuration
    play_game(&board);         // Exécution
    return 0;
}
```

**Pourquoi si simple ?**
- **Principe de responsabilité unique** : main() ne fait qu'orchestrer
- **Facilite les tests** : la logique est dans les modules dédiés
- **Lisibilité** : le flux d'exécution est immédiatement visible

### 2. **board.h** - Le contrat de données (50 lignes)

**Contenu structuré** :

#### Constantes globales
```c
#define BOARD_SIZE 10    // Taille du plateau
#define NUM_SHIPS 5      // Nombre de navires  
#define MAX_MISSES 20    // Limite de tirs ratés
```

#### Types de données métier
```c
typedef enum {
    CELL_EMPTY, CELL_SHIP, CELL_HIT, CELL_MISS
} CellType;

typedef struct {
    int row, col;           // Position 0-9
} Position;

typedef struct {
    char name[20];          // "Porte-avions"
    int size;               // 5 cases
} Boat;
```

**Avantages de cette organisation** :
- **Centralisation** : toutes les constantes au même endroit
- **Type safety** : enum empêche les erreurs de valeurs
- **Documentation** : les structures sont auto-documentées

### 3. **board.c** - Le gestionnaire de données (150 lignes)

#### Tableau des navires statique
```c
static Boat ships[NUM_SHIPS] = {
    {"Porte-avions", 5},
    {"Croiseur", 4},
    {"Destroyer-1", 3},
    {"Destroyer-2", 3},
    {"Torpilleur", 2}
};
```

#### Fonctions de base
- **`init_board()`** : Remise à zéro complète
- **`can_place_ship()`** : Validation avant placement
- **`place_ship()`** : Modification effective du plateau
- **`print_board()`** : Affichage avec option de masquage

**Choix techniques cruciaux** :

**1. Fonction `print_board()` avec paramètre `hide_ships`**
```c
void print_board(Board *board, int hide_ships);
```
- `hide_ships = 0` → Pendant le placement (navires visibles)
- `hide_ships = 1` → Pendant le jeu (navires masqués)
- **Avantage** : Une seule fonction pour deux usages différents
- **Alternative écartée** : Deux fonctions séparées (code dupliqué)

**2. Validation rigoureuse dans `can_place_ship()`**
```c
// Vérification des limites
if (start.col + size > BOARD_SIZE) return 0;

// Vérification des collisions  
for (i = 0; i < size; i++) {
    if (board->cells[start.row][start.col + i] != CELL_EMPTY) 
        return 0;
}
```

### 4. **game.h** - Interface de la logique métier (25 lignes)

**Organisation par responsabilité** :
- **Placement** : `choose_placement()`, `place_ships_manually()`, `place_ships_randomly()`
- **Jeu** : `get_player_input()`, `attack()`, `check_victory()`, `play_game()`
- **Utilitaires** : `parse_coordinates()`, `get_orientation_input()`

### 5. **game.c** - La logique métier complexe (250 lignes)

#### Gestion sophistiquée des entrées utilisateur

**Parsing robuste des coordonnées** :
```c
Position parse_coordinates(const char *input) {
    // Gère A1-J10, a1-j10, validation complète
    if (col_char >= 'A' && col_char <= 'J') {
        pos.col = col_char - 'A';
    } else if (col_char >= 'a' && col_char <= 'j') {
        pos.col = col_char - 'a';  // Majuscules/minuscules
    }
    
    // Cas spécial pour "10"
    if (input[1] == '1' && input[2] == '0' && input[3] == '\0') {
        pos.row = 9;
    }
}
```

#### Placement aléatoire intelligent
```c
int place_ships_randomly(Board *board) {
    int attempts = 0, max_attempts = 1000;
    
    while (attempts < max_attempts) {
        Position pos = {rand() % 10, rand() % 10};
        char orientation = (rand() % 2 == 0) ? 'H' : 'V';
        
        if (can_place_ship(board, pos, size, orientation)) {
            place_ship(board, pos, size, orientation);
            return 1; // Succès
        }
        attempts++;
    }
    return 0; // Échec après 1000 tentatives
}
```

**Pourquoi 1000 tentatives maximum ?**
- **Évite les boucles infinies** sur des plateaux presque pleins
- **Performance** : temps de réponse acceptable
- **Fallback** : arrêt propre avec message d'erreur

#### Fonction `attack()` avec codes de retour explicites
```c
int attack(Board *board, Position pos, int *miss_counter) {
    switch (board->cells[pos.row][pos.col]) {
        case CELL_SHIP:
            board->cells[pos.row][pos.col] = CELL_HIT;
            return 1;  // Touché
        case CELL_EMPTY:
            board->cells[pos.row][pos.col] = CELL_MISS;
            (*miss_counter)++;
            return 0;  // Manqué
        case CELL_HIT:
        case CELL_MISS:
            return -1; // Déjà attaqué
    }
}
```

---

## Justifications des choix de gameplay

### 1. **Pourquoi masquer les navires après placement ?**

**Réalisme tactique** :
- Simule le "brouillard de guerre" naval authentique
- Force le joueur à mémoriser et déduire les positions
- Augmente la tension et l'intérêt du jeu

**Implementation** :
```c
choose_placement(&board);  // Navires visibles pendant placement
play_game(&board);         // Navires masqués pendant le jeu
```

### 2. **Pourquoi limiter à 20 tirs ratés ?**

**Équilibrage du gameplay** :
- **Sans limite** : parties infinies par tâtonnement systématique
- **Avec limite** : nécessité de stratégie et réflexion tactique
- **20 tirs** : équilibre entre challenge et jouabilité (17 cases navires + marge)

**Calcul de la limite** :
- Total cases navires : 5+4+3+3+2 = **17 cases**
- Marge d'erreur accordée : **3 tirs** (17%)
- Limite finale : **20 tirs ratés**

### 3. **Pourquoi les symboles X, ~, . ?**

**Intuitivité visuelle** :
- **`X`** = universellement associé à "touché/détruit"
- **`~`** = évoque les vagues, "dans l'eau"
- **`.`** = terrain neutre/inconnu, discret visuellement
- **`O`** = navire visible (placement uniquement)

---

## 🔧 Avantages techniques de l'architecture

### 1. **Modularité et réutilisabilité**

```
board.c peut être réutilisé pour :
├── Battleship multijoueur
├── IA contre joueur  
├── Variantes de règles
└── Interface graphique
```

### 2. **Testabilité indépendante**

```c
// Test unitaire du plateau
Board test_board;
init_board(&test_board);
Position pos = {0, 0};
assert(can_place_ship(&test_board, pos, 5, 'H') == 1);

// Test unitaire du parsing
Position result = parse_coordinates("A1");
assert(result.row == 0 && result.col == 0);
```

### 3. **Gestion d'erreurs robuste**

**Codes de retour standardisés** :
- `-1` = Erreur (entrée invalide, case déjà visée)
- `0` = Action valide mais ratée  
- `1` = Action valide et réussie

**Validation à tous les niveaux** :
- Coordonnées hors plateau
- Formats d'entrée incorrects
- Collisions de navires
- Cases déjà attaquées

### 4. **Performance optimisée**

**Complexité algorithmique** :
- `can_place_ship()` : O(taille_navire) ≤ O(5)
- `check_victory()` : O(100) pour 10×10
- `print_board()` : O(100) pour l'affichage

**Mémoire** :
- Structure Board : 100 bytes (10×10 enum)
- Pas d'allocations dynamiques
- Footprint mémoire minimal

---

## 👥 Organisation pour équipe de 4 étudiants

### **Répartition suggérée des tâches**

#### **Étudiant 1 - Spécialiste Données** 
**Responsabilités** : `board.h` + `board.c`
- Définir les structures de données
- Implémenter la gestion du plateau
- Créer les fonctions de placement et validation
- **Compétences développées** : Structures, algorithmes, gestion mémoire

#### **Étudiant 2 - Spécialiste Logique**
**Responsabilités** : `game.h` + `game.c` 
- Développer l'interaction utilisateur
- Implémenter les règles du jeu
- Gérer les boucles de jeu et conditions de fin
- **Compétences développées** : Logique métier, parsing, gestion d'état

#### **Étudiant 3 - Intégrateur**
**Responsabilités** : `main.c` + Tests + Documentation
- Assembler les modules
- Tester l'intégration complète
- Valider le respect des spécifications
- **Compétences développées** : Architecture, tests, documentation

#### **Étudiant 4 - Responsable Qualité**
**Responsabilités** : Validation + Optimisation + Polish
- Tester les cas limites et gestion d'erreurs
- Optimiser les performances
- Améliorer l'expérience utilisateur (messages, affichage)
- **Compétences développées** : Tests, optimisation, UX

### **Workflow collaboratif recommandé**

```
Phase 1 : Conception des interfaces (Tous ensemble)
├── Définir board.h (structures communes)
├── Définir game.h (prototypes)
└── Valider l'architecture

Phase 2 : Développement parallèle (2 semaines)  
├── Étudiant 1 → board.c
├── Étudiant 2 → game.c  
├── Étudiant 3 → main.c + tests basiques
└── Étudiant 4 → documentation + spécifications

Phase 3 : Intégration et validation (1 semaine)
├── Étudiant 3 → Assemblage final
├── Étudiant 4 → Tests complets
├── Tous → Debug collaboratif
└── Tous → Validation finale
```

### **Avantages de cette répartition**

**Travail parallèle efficace** :
- Interfaces claires = pas de blocages entre équipiers
- Chacun peut tester son module indépendamment
- Intégration finale facilitée

**Apprentissage complémentaire** :
- Chaque étudiant se spécialise dans un domaine
- Partage de connaissances lors des revues de code
- Vision complète du projet pour tous

**Gestion des conflits minimisée** :
- Séparation physique des fichiers
- Interfaces figées dès le début
- Responsabilités claires et non-chevauchantes

---

## Extensions possibles

L'architecture modulaire permet facilement d'ajouter :

### **Nouvelles fonctionnalités**
```c
// Dans board.h
typedef enum {
    SHIP_CARRIER, SHIP_BATTLESHIP, SHIP_DESTROYER, 
    SHIP_SUBMARINE, SHIP_PATROL  // Nouveaux types
} ShipType;

// Dans game.c
void play_multiplayer_game(Board *player1, Board *player2);
void play_against_ai(Board *player, Board *ai);
```

### **Variantes de règles**
- Plateaux de tailles différentes (modifer BOARD_SIZE)
- Nouveaux types de navires (étendre le tableau ships[])
- Règles spéciales (tirs multiples, mines, etc.)

### **Interface améliorée**
- Couleurs avec les codes ANSI
- Sons avec system() calls
- Sauvegarde/chargement de parties

---

##Métriques de qualité du code

### **Lisibilité**
- **Noms explicites** : `can_place_ship()` vs `check()`
- **Fonctions courtes** : Moyenne 15 lignes par fonction
- **Commentaires pertinents** : Expliquent le "pourquoi", pas le "quoi"

### **Maintenabilité** 
- **Couplage faible** : board.c ne dépend pas de game.c
- **Cohésion forte** : chaque module a une responsabilité claire
- **Constantes centralisées** : modification facile des paramètres

### **Robustesse**
- **Gestion complète des erreurs** : Tous les scanf() vérifiés
- **Validation systématique** : Toutes les entrées utilisateur contrôlées
- **Cas limites couverts** : Bords du plateau, collisions, etc.

Cette architecture représente un **excellent compromis** entre simplicité d'apprentissage et qualité professionnelle, parfaitement adaptée pour un projet étudiant collaboratif !
