# Rapport Technique DÃ©taillÃ© - Battleship-2025

## Vue d'ensemble de l'architecture

Le projet Battleship-2025 suit une **architecture modulaire en couches** qui sÃ©pare clairement les responsabilitÃ©s :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   main.c    â”‚  â† Point d'entrÃ©e et orchestration
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   game.c    â”‚  â† Logique mÃ©tier et interactions
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   board.c   â”‚  â† Gestion des donnÃ©es du plateau
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Cette organisation respecte le principe de **sÃ©paration des prÃ©occupations** et facilite la maintenance, les tests et le travail en Ã©quipe.

---

## Analyse dÃ©taillÃ©e de chaque fichier

### 1. **main.c** - Le chef d'orchestre (30 lignes)

**RÃ´le unique** : Coordonner l'exÃ©cution du programme sans logique mÃ©tier.

```c
int main(void) {
    Board board;
    init_board(&board);        // Initialisation
    choose_placement(&board);  // Configuration
    play_game(&board);         // ExÃ©cution
    return 0;
}
```

**Pourquoi si simple ?**
- **Principe de responsabilitÃ© unique** : main() ne fait qu'orchestrer
- **Facilite les tests** : la logique est dans les modules dÃ©diÃ©s
- **LisibilitÃ©** : le flux d'exÃ©cution est immÃ©diatement visible

### 2. **board.h** - Le contrat de donnÃ©es (50 lignes)

**Contenu structurÃ©** :

#### Constantes globales
```c
#define BOARD_SIZE 10    // Taille du plateau
#define NUM_SHIPS 5      // Nombre de navires  
#define MAX_MISSES 20    // Limite de tirs ratÃ©s
```

#### Types de donnÃ©es mÃ©tier
```c
typedef enum {
    CELL_EMPTY, CELL_SHIP, CELL_HIT, CELL_MISS
} CellType;

typedef struct {
    int row, col;           // Position 0-9
} Position;

typedef struct {
    char name[20];          // "Porte-avions"
    int size;               // 5 cases
} Boat;
```

**Avantages de cette organisation** :
- **Centralisation** : toutes les constantes au mÃªme endroit
- **Type safety** : enum empÃªche les erreurs de valeurs
- **Documentation** : les structures sont auto-documentÃ©es

### 3. **board.c** - Le gestionnaire de donnÃ©es (150 lignes)

#### Tableau des navires statique
```c
static Boat ships[NUM_SHIPS] = {
    {"Porte-avions", 5},
    {"Croiseur", 4},
    {"Destroyer-1", 3},
    {"Destroyer-2", 3},
    {"Torpilleur", 2}
};
```

#### Fonctions de base
- **`init_board()`** : Remise Ã  zÃ©ro complÃ¨te
- **`can_place_ship()`** : Validation avant placement
- **`place_ship()`** : Modification effective du plateau
- **`print_board()`** : Affichage avec option de masquage

**Choix techniques cruciaux** :

**1. Fonction `print_board()` avec paramÃ¨tre `hide_ships`**
```c
void print_board(Board *board, int hide_ships);
```
- `hide_ships = 0` â†’ Pendant le placement (navires visibles)
- `hide_ships = 1` â†’ Pendant le jeu (navires masquÃ©s)
- **Avantage** : Une seule fonction pour deux usages diffÃ©rents
- **Alternative Ã©cartÃ©e** : Deux fonctions sÃ©parÃ©es (code dupliquÃ©)

**2. Validation rigoureuse dans `can_place_ship()`**
```c
// VÃ©rification des limites
if (start.col + size > BOARD_SIZE) return 0;

// VÃ©rification des collisions  
for (i = 0; i < size; i++) {
    if (board->cells[start.row][start.col + i] != CELL_EMPTY) 
        return 0;
}
```

### 4. **game.h** - Interface de la logique mÃ©tier (25 lignes)

**Organisation par responsabilitÃ©** :
- **Placement** : `choose_placement()`, `place_ships_manually()`, `place_ships_randomly()`
- **Jeu** : `get_player_input()`, `attack()`, `check_victory()`, `play_game()`
- **Utilitaires** : `parse_coordinates()`, `get_orientation_input()`

### 5. **game.c** - La logique mÃ©tier complexe (250 lignes)

#### Gestion sophistiquÃ©e des entrÃ©es utilisateur

**Parsing robuste des coordonnÃ©es** :
```c
Position parse_coordinates(const char *input) {
    // GÃ¨re A1-J10, a1-j10, validation complÃ¨te
    if (col_char >= 'A' && col_char <= 'J') {
        pos.col = col_char - 'A';
    } else if (col_char >= 'a' && col_char <= 'j') {
        pos.col = col_char - 'a';  // Majuscules/minuscules
    }
    
    // Cas spÃ©cial pour "10"
    if (input[1] == '1' && input[2] == '0' && input[3] == '\0') {
        pos.row = 9;
    }
}
```

#### Placement alÃ©atoire intelligent
```c
int place_ships_randomly(Board *board) {
    int attempts = 0, max_attempts = 1000;
    
    while (attempts < max_attempts) {
        Position pos = {rand() % 10, rand() % 10};
        char orientation = (rand() % 2 == 0) ? 'H' : 'V';
        
        if (can_place_ship(board, pos, size, orientation)) {
            place_ship(board, pos, size, orientation);
            return 1; // SuccÃ¨s
        }
        attempts++;
    }
    return 0; // Ã‰chec aprÃ¨s 1000 tentatives
}
```

**Pourquoi 1000 tentatives maximum ?**
- **Ã‰vite les boucles infinies** sur des plateaux presque pleins
- **Performance** : temps de rÃ©ponse acceptable
- **Fallback** : arrÃªt propre avec message d'erreur

#### Fonction `attack()` avec codes de retour explicites
```c
int attack(Board *board, Position pos, int *miss_counter) {
    switch (board->cells[pos.row][pos.col]) {
        case CELL_SHIP:
            board->cells[pos.row][pos.col] = CELL_HIT;
            return 1;  // TouchÃ©
        case CELL_EMPTY:
            board->cells[pos.row][pos.col] = CELL_MISS;
            (*miss_counter)++;
            return 0;  // ManquÃ©
        case CELL_HIT:
        case CELL_MISS:
            return -1; // DÃ©jÃ  attaquÃ©
    }
}
```

---

## Justifications des choix de gameplay

### 1. **Pourquoi masquer les navires aprÃ¨s placement ?**

**RÃ©alisme tactique** :
- Simule le "brouillard de guerre" naval authentique
- Force le joueur Ã  mÃ©moriser et dÃ©duire les positions
- Augmente la tension et l'intÃ©rÃªt du jeu

**Implementation** :
```c
choose_placement(&board);  // Navires visibles pendant placement
play_game(&board);         // Navires masquÃ©s pendant le jeu
```

### 2. **Pourquoi limiter Ã  20 tirs ratÃ©s ?**

**Ã‰quilibrage du gameplay** :
- **Sans limite** : parties infinies par tÃ¢tonnement systÃ©matique
- **Avec limite** : nÃ©cessitÃ© de stratÃ©gie et rÃ©flexion tactique
- **20 tirs** : Ã©quilibre entre challenge et jouabilitÃ© (17 cases navires + marge)

**Calcul de la limite** :
- Total cases navires : 5+4+3+3+2 = **17 cases**
- Marge d'erreur accordÃ©e : **3 tirs** (17%)
- Limite finale : **20 tirs ratÃ©s**

### 3. **Pourquoi les symboles X, ~, . ?**

**IntuitivitÃ© visuelle** :
- **`X`** = universellement associÃ© Ã  "touchÃ©/dÃ©truit"
- **`~`** = Ã©voque les vagues, "dans l'eau"
- **`.`** = terrain neutre/inconnu, discret visuellement
- **`O`** = navire visible (placement uniquement)

---

## ğŸ”§ Avantages techniques de l'architecture

### 1. **ModularitÃ© et rÃ©utilisabilitÃ©**

```
board.c peut Ãªtre rÃ©utilisÃ© pour :
â”œâ”€â”€ Battleship multijoueur
â”œâ”€â”€ IA contre joueur  
â”œâ”€â”€ Variantes de rÃ¨gles
â””â”€â”€ Interface graphique
```

### 2. **TestabilitÃ© indÃ©pendante**

```c
// Test unitaire du plateau
Board test_board;
init_board(&test_board);
Position pos = {0, 0};
assert(can_place_ship(&test_board, pos, 5, 'H') == 1);

// Test unitaire du parsing
Position result = parse_coordinates("A1");
assert(result.row == 0 && result.col == 0);
```

### 3. **Gestion d'erreurs robuste**

**Codes de retour standardisÃ©s** :
- `-1` = Erreur (entrÃ©e invalide, case dÃ©jÃ  visÃ©e)
- `0` = Action valide mais ratÃ©e  
- `1` = Action valide et rÃ©ussie

**Validation Ã  tous les niveaux** :
- CoordonnÃ©es hors plateau
- Formats d'entrÃ©e incorrects
- Collisions de navires
- Cases dÃ©jÃ  attaquÃ©es

### 4. **Performance optimisÃ©e**

**ComplexitÃ© algorithmique** :
- `can_place_ship()` : O(taille_navire) â‰¤ O(5)
- `check_victory()` : O(100) pour 10Ã—10
- `print_board()` : O(100) pour l'affichage

**MÃ©moire** :
- Structure Board : 100 bytes (10Ã—10 enum)
- Pas d'allocations dynamiques
- Footprint mÃ©moire minimal

---

## ğŸ‘¥ Organisation pour Ã©quipe de 4 Ã©tudiants

### **RÃ©partition suggÃ©rÃ©e des tÃ¢ches**

#### **Ã‰tudiant 1 - SpÃ©cialiste DonnÃ©es** 
**ResponsabilitÃ©s** : `board.h` + `board.c`
- DÃ©finir les structures de donnÃ©es
- ImplÃ©menter la gestion du plateau
- CrÃ©er les fonctions de placement et validation
- **CompÃ©tences dÃ©veloppÃ©es** : Structures, algorithmes, gestion mÃ©moire

#### **Ã‰tudiant 2 - SpÃ©cialiste Logique**
**ResponsabilitÃ©s** : `game.h` + `game.c` 
- DÃ©velopper l'interaction utilisateur
- ImplÃ©menter les rÃ¨gles du jeu
- GÃ©rer les boucles de jeu et conditions de fin
- **CompÃ©tences dÃ©veloppÃ©es** : Logique mÃ©tier, parsing, gestion d'Ã©tat

#### **Ã‰tudiant 3 - IntÃ©grateur**
**ResponsabilitÃ©s** : `main.c` + Tests + Documentation
- Assembler les modules
- Tester l'intÃ©gration complÃ¨te
- Valider le respect des spÃ©cifications
- **CompÃ©tences dÃ©veloppÃ©es** : Architecture, tests, documentation

#### **Ã‰tudiant 4 - Responsable QualitÃ©**
**ResponsabilitÃ©s** : Validation + Optimisation + Polish
- Tester les cas limites et gestion d'erreurs
- Optimiser les performances
- AmÃ©liorer l'expÃ©rience utilisateur (messages, affichage)
- **CompÃ©tences dÃ©veloppÃ©es** : Tests, optimisation, UX

### **Workflow collaboratif recommandÃ©**

```
Phase 1 : Conception des interfaces (Tous ensemble)
â”œâ”€â”€ DÃ©finir board.h (structures communes)
â”œâ”€â”€ DÃ©finir game.h (prototypes)
â””â”€â”€ Valider l'architecture

Phase 2 : DÃ©veloppement parallÃ¨le (2 semaines)  
â”œâ”€â”€ Ã‰tudiant 1 â†’ board.c
â”œâ”€â”€ Ã‰tudiant 2 â†’ game.c  
â”œâ”€â”€ Ã‰tudiant 3 â†’ main.c + tests basiques
â””â”€â”€ Ã‰tudiant 4 â†’ documentation + spÃ©cifications

Phase 3 : IntÃ©gration et validation (1 semaine)
â”œâ”€â”€ Ã‰tudiant 3 â†’ Assemblage final
â”œâ”€â”€ Ã‰tudiant 4 â†’ Tests complets
â”œâ”€â”€ Tous â†’ Debug collaboratif
â””â”€â”€ Tous â†’ Validation finale
```

### **Avantages de cette rÃ©partition**

**Travail parallÃ¨le efficace** :
- Interfaces claires = pas de blocages entre Ã©quipiers
- Chacun peut tester son module indÃ©pendamment
- IntÃ©gration finale facilitÃ©e

**Apprentissage complÃ©mentaire** :
- Chaque Ã©tudiant se spÃ©cialise dans un domaine
- Partage de connaissances lors des revues de code
- Vision complÃ¨te du projet pour tous

**Gestion des conflits minimisÃ©e** :
- SÃ©paration physique des fichiers
- Interfaces figÃ©es dÃ¨s le dÃ©but
- ResponsabilitÃ©s claires et non-chevauchantes

---

## Extensions possibles

L'architecture modulaire permet facilement d'ajouter :

### **Nouvelles fonctionnalitÃ©s**
```c
// Dans board.h
typedef enum {
    SHIP_CARRIER, SHIP_BATTLESHIP, SHIP_DESTROYER, 
    SHIP_SUBMARINE, SHIP_PATROL  // Nouveaux types
} ShipType;

// Dans game.c
void play_multiplayer_game(Board *player1, Board *player2);
void play_against_ai(Board *player, Board *ai);
```

### **Variantes de rÃ¨gles**
- Plateaux de tailles diffÃ©rentes (modifer BOARD_SIZE)
- Nouveaux types de navires (Ã©tendre le tableau ships[])
- RÃ¨gles spÃ©ciales (tirs multiples, mines, etc.)

### **Interface amÃ©liorÃ©e**
- Couleurs avec les codes ANSI
- Sons avec system() calls
- Sauvegarde/chargement de parties

---

##MÃ©triques de qualitÃ© du code

### **LisibilitÃ©**
- **Noms explicites** : `can_place_ship()` vs `check()`
- **Fonctions courtes** : Moyenne 15 lignes par fonction
- **Commentaires pertinents** : Expliquent le "pourquoi", pas le "quoi"

### **MaintenabilitÃ©** 
- **Couplage faible** : board.c ne dÃ©pend pas de game.c
- **CohÃ©sion forte** : chaque module a une responsabilitÃ© claire
- **Constantes centralisÃ©es** : modification facile des paramÃ¨tres

### **Robustesse**
- **Gestion complÃ¨te des erreurs** : Tous les scanf() vÃ©rifiÃ©s
- **Validation systÃ©matique** : Toutes les entrÃ©es utilisateur contrÃ´lÃ©es
- **Cas limites couverts** : Bords du plateau, collisions, etc.

Cette architecture reprÃ©sente un **excellent compromis** entre simplicitÃ© d'apprentissage et qualitÃ© professionnelle, parfaitement adaptÃ©e pour un projet Ã©tudiant collaboratif !
